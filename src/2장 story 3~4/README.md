# 데이터 송/수신과 소켓 말소

## 목차

story 03 : 데이터를 송/수신한다

- 데이터 송신과 분할
- ACK로 패킷 도착 확인
- 윈도우 제어

story 04 : 서버에서 연결을 끊어 소켓을 말소한다

- 연결 종료와 소켓 말소

## Story 03 : 데이터를 송/수신한다

### 데이터 송신과 분할

1. connnect 로 연결이 완료된 후, 애플리케이션에 제어가 넘어감
2. write를 호출해 송신 데이터를 프로토콜 스택에 전달
3. 프로토콜 스택은 송신용 버퍼 메모리에 데이터를 일단 저장 
- 패킷을 여러번 보내면 네트워크 이용 효율이 저하되므로, 어느정도 저장 후 송/수신

**판단 요소**
1. 한 패킷에 저장할 수 있는 데이터 크기 MSS : 헤더를 제외한 TCP 데이터 최대 길이 <br/>
(MTU : 패킷 한 개로 운반 가능한 디지털 데이터 최대 길이)
2. 타이밍 : 송신 동작의 지연을 막기 위해 내부 타이머가 일정 시간이 경과하면 전송

둘은 서로 상반된 요소이기 때문에, OS에 따라 프로토콜 스택의 판단은 달라짐 - 애플리케이션이 제어할 수도 있음

**데이터 분할**
MSS의 길이를 초과한 경우, 데이터를 분할해 각각 패킷에 넣어 송신
송신 버퍼에서 TCP 헤더 부가하고 송신 동작 실행

### ACK로 패킷 도착 확인

#### TCP에서는 데이터가 도착하지 않으면 다시 송신하는 기능을 제공

데이터를 분할해 전송할 때, 몇 번째 바이트인지 TCP 헤더에 기록 (시퀀스 번호)
수신측에서는 시퀀스 번호와 수신한 데이터의 크기를 계산해 패킷의 누락을 확인
현재 몇 바이트까지 수신한 지 계산해 TCP 헤더의 ACK 번호에 기록해 송신측에 전달

<img src="https://github.com/user-attachments/assets/5747428e-137b-4680-9f26-09b1e4ec1d7b" />

실제로는 시퀀스 번호가 1부터 시작하지 않고 난수 활용 (TCP 세션 하이재킹, TCP RST공격 등을 방지)
접속 동작에서 SYN 을 1로 하여 전송할 때, 시퀀스 번호의 초깃값도 전달 <br/>

<img src='https://github.com/user-attachments/assets/a865e184-c008-4456-88d4-9390e1b20d6d' />

실제로는 양방향으로 진행됨
TCP는 상대가 데이터를 받았는 지 확인이 될 때까지(ACK 번호) 송신한 패킷을 송신용 버퍼 메모리에 보관했다가
실패시 재전송

#### ACK 번호가 돌아오는 것을 기다리는 시간 : 타임아웃 값

**타임아웃을 결정하기 위해 고려할 사항**
- 패킷 재전송을 여러번 시도할 경우, 네트워크 혼잡을 악화시킴
- 너무 대기시간이 길면 속도 저하

TCP는 대기시간을 동적으로 변경해 해결

### 윈도우 제어

#### 윈도우 제어란 : ACK 를 기다리는 동안에도 패킷을 보내 시간 낭비를 줄이는 방식

- 발생 가능한 문제 : 패킷을 계속 보내면 수신 버퍼가 넘쳐 데이터 소실.
-> 수신 가능한 데이터 양을 통지해 윈도우를 제어해야 함. - TCP의 윈도우 필드에서 송신측에 전달


<img src='https://github.com/user-attachments/assets/f9436e0e-437a-4c4c-9e82-b3e55dcd44c4'/>

- ACK 번호와 윈도우 통지의 합승
ACK는 수신 후 즉시, 윈도우 통지는 수신 버퍼에서 애플리케이션에 데이터를 넘겨 빈 영역이 생겼을 때 송신. <br/>
하지만, ACK 번호 통지나 윈도우 통지는 연속될 경우, **마지막 값만 전달하면 됨.**
따라서 효율성을 위해 합승시켜 전송해야 할 패킷 수를 줄일 수 있다.

## Story 04 서버에서 연결을 끊어 소켓을 말소한다.

### 연결 종료와 소켓 말소

연결 끊기는 송신을 완료한 측이 시작 - 웹의 경우 클라이언트가 요청 후 서버의 응답으로 끝나기 때문에
서버가 연결끊기를 시작. (받을 데이터가 없는 쪽이 연결 끊기를 시작함)

데이터 보내기가 완료된 후, 서버에서 close를 호출해 FIN을 1로 설정하고 송신

4-way handshake의 방식으로 연결을 종료

왜 4-way handshake를 사용할까? 서버는 FIN을 보내도, 클라이언트는 아직 데이터를 수신하고 있을 수 있음.(네트워크 지연 등으로 인해)
서버의 FIN 이후에 데이터가 유실되면, 손실된 데이터를 재전송 (송신 버퍼에 남아있는 값) FIN을 다시 보내진 않음.
https://junb51.tistory.com/4

<img width="624" src="https://github.com/user-attachments/assets/2d4b3e85-4c7d-4bb0-bd19-df11f31c6dd6" />

서버와 대화가 끝나면 잠시 기다린 후에 소켓을 말소.
오동작을 막기 위해 잠시 대기함.

소켓을 바로 말소할 경우,
서버가 FIN을 송신하고 클라이언트가 ACK를 송신하는 과정에서 서버가 FIN을 한 번 더 보냈다면,
새로 실행되는 애플리케이션의 소켓에 같은 포트 번호가 할당될 경우, 바로 종료 동작을 실행

다시 보낸 패킷이 네트워크에 남아있을 가능성이 있는 시간을 고려해 몇 분 정도 대기 후 소켓을 말소

전체적인 TCP 송/수신 동작

<img src='https://github.com/user-attachments/assets/ca011459-4464-451d-af4b-3056257e3bbb' />
