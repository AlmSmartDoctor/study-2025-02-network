# 소켓 작성과 서버 접속

## 목차

story 01 : 소켓을 작성한다.

- 프로토콜 스택 내부 구성
- 소켓의 실체

story 02 : 서버에 접속한다.

- 접속 과정

### 1장 내용 회고

1장까지의 내용 - HTTP 리퀘스트 메시지의 구성과 IP 주소.
DNS 서버로부터 IP주소를 받아 브라우저에서 OS의 프로토콜 스택에 데이터 송/수신을 의뢰.

## Story 01 : 소켓을 작성한다.

### 프로토콜 스택 내부 구성

#### 프로토콜 스택이란? : 네트워크 통신을 위해 여러 프로토콜이 계층적으로 쌓인 구조 (통신에 사용되는 프로토콜의 조합)
/ OS에 내장된 네트워크 제어용 소프트웨어


TCP/IP 소프트웨어의 계층 구조 <br/>
<img src='https://github.com/user-attachments/assets/633b6a70-65ff-4a9c-8a3e-5d62046de14c' height='400'/>
<img src='https://github.com/user-attachments/assets/9d8fc19d-1f00-4b4f-a86b-5111928ebec1' />

TCP/IP 5계층 모델과 대응됨 (네트워크 통신 계층 모델)

- 네트워크 애플리케이션 : 브라우저, 메일러, 웹 서버, 메일 서버 등의 프로그램. 데이터의 내용이 다를 뿐, 송/수신 동작은 동일
- **프로토콜 스택** : OS 내부. TCP/UDP 프로토콜로 데이터 송/수신을 담당하는 부분, IP 프로토콜로 패킷 송/수신을 담당하는 부분.
  일반적인 경우 TCP 사용, 짧은 제어용 데이터는 UDP 사용. TCP는 연결형, UDP는 비연결형 (stroy 06)
  IP에는 ICMP와 ARP라는 부분이 있음. ICMP는 패킷 운반 오류 통지, 제어용 메시지. ARP는 IP주소에 대응하는 이더넷의 MAC주소 조사
- LAN 드라이버
- LAN 어댑터

### 소켓의 실체

#### 소켓이란? : OS가 TCP/IP 프로토콜 스택을 통해 네트워크 통신을 할 수 있도록 제공하는 인터페이스 - 제어 정보를 기록한 메모리 영역

프로토콜 스책은 소켓의 제어 정보를 참조하면서 동작

소켓이 저장하는 정보 : IP 주소, 포트 번호, 응답 여부, 송신 후 경과 시간 등
데이터 송/수신 과정에서 필요한 정보를 저장

소켓 주요 정보 확인
- 윈도우 : netstat
- macOS : lsof (netstat)
- 리눅스 : ss

각 행 - 하나의 소켓

State : 통신 상태 (CLOSE_WAIT, CLOSED, ESTABLISHED, FIN_WAIT_1,2, LISTEN, ...) ESTABLISHED - 통신중, LISTENING - 접속 기다리는 중
https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/netstat <br/>
PID : 프로세스 아이디 - 작업관리자로 프로그램 확인 가능

자신의 IP주소와 연결된 포트 번호, 상대의 IP 주소와 포트 번호 등의 정보를 파악할 수 있음.
**IP 주소가 0.0.0.0인 경우** : 아직 통신이 시작되지 않아 IP 주소가 정해지지 않은 것
**IP주소가 \*:\* 인 경우** : UDP 프로토콜을 사용한 경우. UDP프로토콜은 소켓을 연결하지 않으므로.


## Story 02 : 서버에 접속한다.

### 접속 과정

#### 접속의 의미

이더넷/통신회선은 항상 연결되어 있음. **"접속"은 통신 상대와 제어 정보를 주고받아 소켓에 기록하고 송/수신이 가능한 상태로 만드는 것.**

접속 동작
- 서버의 IP 주소, 포트 번호를 프로토콜 스택에 전달
- 클라이언트측에서 서버측에 통신 동작의 개시를 전달
- 데이터를 일시적으로 저장하는 버퍼 메모리 확보

#### 제어 정보 
1. 헤더에 기입되는 정보
2. 소켓(프로토콜 스택의 메모리 영역)에 기록되는 정보

#### 헤더에 기입되는 정보 <br/>
<img src='https://github.com/user-attachments/assets/18b58b8a-8b94-475a-ae0f-2d19ea2ce656' /> <br/>
패킷(데이터 조각)을 송/수신할 때 패킷의 앞 부분에 추가해 제어 정보를 전송한다.
접속 시에는 데이터가 없이 제어 정보로만 이루어진 패킷을 보냄.

<img src='https://github.com/user-attachments/assets/a17866d9-3e63-4996-9095-58da44bfb47f' /> <br/>
계층에서 프로토콜을 선택하고 패킷에 헤더를 추가

#### 소켓에 기록되는 정보 <br/>
프로토콜 스택에 따라 달라짐 = OS 에 따라서 달라짐 (IP 주소, 포트 번호 등의 중요한 정보는 공통 - netstat 등으로 확인 가능)


#### 실제 동작하는 방식 (TCP에서 접속이 이루어지는 방식)
- Socket 라이브러리에서 connect()

- 3-Way handshake
<img src="https://github.com/user-attachments/assets/3130b1d2-ae82-42d1-aa10-b51a68ade37e" />
a, b는 각각 시퀀스 번호 초기값


소켓이 데이터를 송/수신할 수 있는 상태가 된다. 소켓이 연결되었다!
이 연결된 커넥션(데이터가 이동하는 논리적 파이프)은 close()를 호출할 때까지 계속 존재.
